---
name: Deploy

on:
  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      image_tag:
        description: "Docker image tag to deploy (leave empty for latest)"
        required: false
        type: string

  # Auto-deploy to dev on develop branch
  push:
    branches:
      - develop

# Auto-deploy to staging on main branch
# Production requires manual approval
# push:
#   branches:
#     - main

concurrency:
  group: >-
    deploy-${{
      github.event.inputs.environment
      || (github.ref == 'refs/heads/develop' && 'development')
      || (github.ref == 'refs/heads/main' && 'staging')
    }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image_tag: ${{ steps.set-env.outputs.image_tag }}

    steps:
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.event.inputs.image_tag || 'latest' }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
          fi

  validate:
    name: Validate Manifests
    runs-on: ubuntu-latest
    needs: determine-environment

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Kubernetes manifests
        run: |
          # Install kubeval for manifest validation
          wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
          tar xf kubeval-linux-amd64.tar.gz
          sudo mv kubeval /usr/local/bin

          # Validate all k8s manifests
          for file in k8s/*.yaml; do
            if [[ "$file" != *"template"* ]]; then
              echo "Validating $file..."
              kubeval "$file" || exit 1
            fi
          done

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, validate]
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: ${{ steps.get-url.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      - name: Configure kubectl
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Set namespace
        id: namespace
        run: |
          NAMESPACE="${{ secrets.KUBE_NAMESPACE }}"
          if [ -z "$NAMESPACE" ]; then
            NAMESPACE="auth-service"
          fi
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "Using namespace: $NAMESPACE"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ steps.namespace.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create ConfigMap
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
        run: |
          # Generate ConfigMap from template
          envsubst < k8s/configmap-template.yaml | kubectl apply -n ${{ steps.namespace.outputs.namespace }} -f -

      - name: Create/Update Secrets
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Create secrets from template
          # Note: In production, use external secrets management (e.g., Sealed Secrets, External Secrets Operator)
          kubectl create secret generic auth-service-secrets \
            --from-literal=jwt-secret="${JWT_SECRET}" \
            --from-literal=redis-password="${REDIS_PASSWORD}" \
            --from-literal=db-password="${DB_PASSWORD}" \
            --namespace=${{ steps.namespace.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Update deployment image
        run: |
          IMAGE_TAG="${{ needs.determine-environment.outputs.image_tag }}"
          IMAGE="ghcr.io/${{ github.repository }}:${IMAGE_TAG}"

          echo "Deploying image: $IMAGE"

          # Update deployment with new image
          kubectl set image deployment/auth-service \
            auth-service=$IMAGE \
            -n ${{ steps.namespace.outputs.namespace }}

      - name: Apply Kubernetes manifests
        run: |
          # Apply all manifests except templates
          for file in k8s/*.yaml; do
            if [[ "$file" != *"template"* ]]; then
              echo "Applying $file..."
              kubectl apply -f "$file" -n ${{ steps.namespace.outputs.namespace }}
            fi
          done

      - name: Wait for rollout to complete
        run: |
          kubectl rollout status deployment/auth-service \
            -n ${{ steps.namespace.outputs.namespace }} \
            --timeout=5m

      - name: Get deployment URL
        id: get-url
        run: |
          # Try to get ingress URL
          NS=${{ steps.namespace.outputs.namespace }}
          INGRESS_URL=$(kubectl get ingress -n $NS \
            -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "")

          if [ -n "$INGRESS_URL" ]; then
            echo "url=https://$INGRESS_URL" >> $GITHUB_OUTPUT
          else
            # Fallback to service
            SERVICE_URL=$(kubectl get svc auth-service -n $NS \
              -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' \
              2>/dev/null || echo "")
            if [ -n "$SERVICE_URL" ]; then
              echo "url=http://$SERVICE_URL" >> $GITHUB_OUTPUT
            else
              echo "url=Service deployed to namespace ${{ steps.namespace.outputs.namespace }}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Display deployment info
        run: |
          echo "=== Deployment Summary ==="
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Namespace: ${{ steps.namespace.outputs.namespace }}"
          echo "Image: ghcr.io/${{ github.repository }}:${{ needs.determine-environment.outputs.image_tag }}"
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n ${{ steps.namespace.outputs.namespace }} -l app=auth-service
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ${{ steps.namespace.outputs.namespace }}

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      - name: Configure kubectl
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Set namespace
        id: namespace
        run: |
          NAMESPACE="${{ secrets.KUBE_NAMESPACE }}"
          if [ -z "$NAMESPACE" ]; then
            NAMESPACE="auth-service"
          fi
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Check pod health
        run: |
          echo "Checking pod health..."
          NS=${{ steps.namespace.outputs.namespace }}
          READY_PODS=$(kubectl get deployment auth-service -n $NS \
            -o jsonpath='{.status.readyReplicas}')
          DESIRED_PODS=$(kubectl get deployment auth-service -n $NS \
            -o jsonpath='{.status.replicas}')

          if [ "$READY_PODS" = "$DESIRED_PODS" ] && [ "$READY_PODS" != "0" ]; then
            echo "‚úÖ All pods are ready ($READY_PODS/$DESIRED_PODS)"
          else
            echo "‚ùå Pods not ready ($READY_PODS/$DESIRED_PODS)"
            kubectl get pods -n ${{ steps.namespace.outputs.namespace }} -l app=auth-service
            exit 1
          fi

      - name: Run health check
        run: |
          echo "Running health check..."

          # Port forward to health endpoint
          NS=${{ steps.namespace.outputs.namespace }}
          kubectl port-forward -n $NS \
            deployment/auth-service 8080:8080 &
          PF_PID=$!

          # Wait for port forward to be ready
          sleep 5

          # Check health endpoint
          HEALTH_URL="http://localhost:8080/api/v1/auth/health"
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            $HEALTH_URL || echo "failed")

          # Cleanup port forward
          kill $PF_PID 2>/dev/null || true

          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed (HTTP $HEALTH_STATUS)"
            exit 1
          fi

      - name: Deployment successful
        run: |
          echo "üéâ Deployment to ${{ needs.determine-environment.outputs.environment }} completed successfully!"
